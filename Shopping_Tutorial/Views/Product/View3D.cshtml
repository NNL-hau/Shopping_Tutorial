@model ProductModel
@using System
@using System.Globalization
@using System.Text.Json
@using System.Text.Encodings.Web
@using System.Linq
@{
    ViewData["Title"] = "3D Viewer - " + Model.Name;
    Layout = "~/Views/Shared/_Layout.cshtml";

    var invariant = CultureInfo.InvariantCulture;
    Func<string?, string> resolveModelPath = (string? path) =>
    {
        if (string.IsNullOrWhiteSpace(path))
        {
            return string.Empty;
        }

        return Uri.IsWellFormedUriString(path, UriKind.Absolute)
            ? path
            : Url.Content(path);
    };

    var modelPath = resolveModelPath(Model.Product3D?.Model3DPath);
    if (string.IsNullOrEmpty(modelPath))
    {
        modelPath = resolveModelPath(Model.Model3DLink);
    }

    var defaultScale = (double)(Model.Product3D?.DefaultScale ?? 1.0m);
    var cameraX = (double)(Model.Product3D?.CameraPositionX ?? 0m);
    var cameraY = (double)(Model.Product3D?.CameraPositionY ?? 2m);
    var cameraZ = (double)(Model.Product3D?.CameraPositionZ ?? 5m);
    var supportAR = Model.Product3D?.SupportAR ?? false;
    var supportVR = Model.Product3D?.SupportVR ?? false;
    var annotationPayload = Model.Annotations?
        .OrderBy(a => a.DisplayOrder)
        .Select(a => new
        {
            title = a.Title,
            content = a.Content,
            x = (double)a.PositionX,
            y = (double)a.PositionY,
            z = (double)a.PositionZ,
            color = a.MarkerColor ?? "#ff4444"
        }) ?? Enumerable.Empty<object>();
    var annotationJson = JsonSerializer.Serialize(annotationPayload, new JsonSerializerOptions
    {
        Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping
    });
    var hasModel3D = !string.IsNullOrEmpty(modelPath);
}

<style>
    #canvas-container {
        width: 100%;
        height: 80vh;
        position: relative;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 10px;
        overflow: hidden;
    }

    .controls-panel {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(15px);
        padding: 10px 20px;
        border-radius: 50px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        z-index: 100;
        display: flex;
        gap: 10px;
        border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .btn-3d {
        background: rgba(255, 255, 255, 0.9);
        color: #3399FF;
        border: none;
        padding: 10px 25px;
        border-radius: 25px;
        cursor: pointer;
        font-weight: 600;
        font-size: 14px;
        transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        display: flex;
        align-items: center;
        gap: 8px;
        white-space: nowrap;
    }

    .btn-3d:hover {
        transform: translateY(-5px);
        background: white;
        box-shadow: 0 5px 15px rgba(51, 153, 255, 0.4);
    }

    .product-info {
        background: white;
        padding: 20px;
        margin-bottom: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .annotation-popup {
        position: absolute;
        background: white;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        max-width: 300px;
        z-index: 200;
        display: none;
    }

    .annotation-popup h4 {
        margin: 0 0 10px 0;
        color: #3399FF;
    }

    .annotation-popup p {
        margin: 0;
        font-size: 14px;
    }


    .annotation-marker {
        position: absolute;
        width: 30px;
        height: 30px;
        background: rgba(51, 153, 255, 0.4);
        border: 2px solid white;
        border-radius: 50%;
        cursor: pointer;
        z-index: 150;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        backdrop-filter: blur(4px);
        transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        pointer-events: auto;
    }

    .annotation-marker::after {
        content: '+';
        font-size: 18px;
    }

    .annotation-marker:hover {
        transform: scale(1.2);
        background: rgba(51, 153, 255, 0.8);
        box-shadow: 0 0 15px rgba(51, 153, 255, 0.5);
    }

    .annotation-marker.pulsing::before {
        content: '';
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        border: 2px solid rgba(51, 153, 255, 0.6);
        animation: pulse-ring 2s infinite;
    }

    @@keyframes pulse-ring {
        0% { transform: scale(1); opacity: 0.8; }
        100% { transform: scale(2.5); opacity: 0; }
    }

    .annotation-popup {
        position: absolute;
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(10px);
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        max-width: 280px;
        z-index: 200;
        display: none;
        border: 1px solid rgba(255, 255, 255, 0.3);
        transform: translate(-50%, -120%);
        transition: opacity 0.3s;
    }

</style>

<div class="container" style="margin-top: 20px;">
    <div class="product-info">
        <h2>@Model.Name</h2>
        <p><strong>Gi√°:</strong> @Model.Price.ToString("#,##0") VNƒê</p>
        <p><strong>Th∆∞∆°ng hi·ªáu:</strong> @Model.Brand?.Name</p>
        <p><strong>Danh m·ª•c:</strong> @Model.Category?.Name</p>
    </div>

    @if (!hasModel3D)
    {
        <div class="alert alert-warning" role="alert">
            Hi·ªán s·∫£n ph·∫©m ch∆∞a c√≥ file 3D (.glb). H·ªá th·ªëng s·∫Ω hi·ªÉn th·ªã m√¥ h√¨nh minh h·ªça ƒë·ªÉ b·∫°n ti·∫øp t·ª•c thao t√°c.
        </div>
    }

    <div id="canvas-container">
        <canvas id="threejs-canvas"></canvas>
        
        <div class="controls-panel">
            <button class="btn-3d" onclick="resetCamera()">üîç Reset</button>
            <button class="btn-3d" onclick="toggleWireframe()">üìê Khung d√¢y</button>
            <button class="btn-3d" onclick="addAnnotation()">‚ûï Ch√∫ th√≠ch</button>
            <button class="btn-3d" onclick="addToCart3D()" style="background: #3399FF; color: white;">üõí Mua ngay</button>
        </div>

        <div id="annotation-popup" class="annotation-popup">
            <h4 id="annotation-title"></h4>
            <p id="annotation-content"></p>
            <button class="btn-3d" onclick="closeAnnotation()" style="margin-top: 10px; padding: 5px 10px;">ƒê√≥ng</button>
        </div>
    </div>

</div>

<!-- Three.js and WebXR libraries -->
<script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
<script src="https://unpkg.com/fflate@0.6.9/umd/index.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/loaders/TDSLoader.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/webxr/VRButton.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/webxr/ARButton.js"></script>

<script>
    let scene, camera, renderer, controls;
    let productMesh = null;
    let annotations = [];
    let wireframeMode = false;
    let arSession = null;
    let vrSession = null;

    const MODEL_PATH = @Html.Raw(JsonSerializer.Serialize(modelPath));
    const HAS_MODEL = @(hasModel3D.ToString().ToLowerInvariant());
    const DEFAULT_SCALE = @(defaultScale.ToString(invariant));
    const CAMERA_POSITION = {
        x: @(cameraX.ToString(invariant)),
        y: @(cameraY.ToString(invariant)),
        z: @(cameraZ.ToString(invariant))
    };
    const SUPPORT_AR = @(supportAR.ToString().ToLowerInvariant());
    const SUPPORT_VR = @(supportVR.ToString().ToLowerInvariant());
    const SERVER_ANNOTATIONS = @Html.Raw(annotationJson);

    // Initialize Three.js scene
    function init3D() {
        const container = document.getElementById('canvas-container');
        const canvas = document.getElementById('threejs-canvas');

        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        // Camera
        camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(CAMERA_POSITION.x, CAMERA_POSITION.y, CAMERA_POSITION.z);

        // Renderer
        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.xr.enabled = true;

        // Controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0xffffff, 0.5);
        pointLight.position.set(-5, 5, -5);
        scene.add(pointLight);

        // Load model + annotations
        loadProductModel();
        loadAnnotationsFromServer();

        // Handle window resize
        window.addEventListener('resize', onWindowResize);

        // Animation loop
        animate();
    }

    function loadProductModel() {
        if (HAS_MODEL && MODEL_PATH) {
            // Detect file format from extension
            const extension = MODEL_PATH.toLowerCase().split('.').pop();
            
            // Get base path for material files
            const basePath = MODEL_PATH.substring(0, MODEL_PATH.lastIndexOf('/') + 1);
            const fileName = MODEL_PATH.substring(MODEL_PATH.lastIndexOf('/') + 1);
            const fileNameWithoutExt = fileName.substring(0, fileName.lastIndexOf('.'));
            
            function onModelLoaded(object) {
                productMesh = object.scene || object;
                productMesh.scale.set(DEFAULT_SCALE, DEFAULT_SCALE, DEFAULT_SCALE);
                productMesh.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                scene.add(productMesh);
            }
            
            function onError(error) {
                console.error('Kh√¥ng th·ªÉ t·∫£i m√¥ h√¨nh 3D', error);
                const errorDiv = document.createElement('div');
                errorDiv.className = 'alert alert-danger';
                errorDiv.style.position = 'absolute';
                errorDiv.style.top = '10px';
                errorDiv.style.left = '10px';
                errorDiv.style.zIndex = '1000';
                errorDiv.style.maxWidth = '80%';
                errorDiv.innerHTML = `<strong>L·ªói t·∫£i m√¥ h√¨nh:</strong> Kh√¥ng th·ªÉ t·∫£i file t·ª´ <code>${MODEL_PATH}</code>.<br>Chi ti·∫øt: ${error.message || 'File kh√¥ng t·ªìn t·∫°i ho·∫∑c l·ªói ƒë·ªãnh d·∫°ng.'}`;
                document.getElementById('canvas-container').appendChild(errorDiv);
                
                createFallbackModel();
            }
            
            switch(extension) {
                case 'glb':
                case 'gltf':
                    const gltfLoader = new THREE.GLTFLoader();
                    gltfLoader.load(MODEL_PATH, onModelLoaded, undefined, onError);
                    break;
                    
                case 'obj':
                    // Try to load MTL file first
                    const mtlPath = basePath + fileNameWithoutExt + '.mtl';
                    const objLoader = new THREE.OBJLoader();
                    
                    // Check if MTL file exists
                    fetch(mtlPath, { method: 'HEAD' })
                        .then(response => {
                            if (response.ok) {
                                // MTL exists, load it first
                                const mtlLoader = new THREE.MTLLoader();
                                mtlLoader.setPath(basePath);
                                mtlLoader.load(fileNameWithoutExt + '.mtl', 
                                    (materials) => {
                                        materials.preload();
                                        objLoader.setMaterials(materials);
                                        objLoader.load(MODEL_PATH, onModelLoaded, undefined, onError);
                                    },
                                    undefined,
                                    () => {
                                        // MTL failed, load OBJ without materials
                                        objLoader.load(MODEL_PATH, onModelLoaded, undefined, onError);
                                    }
                                );
                            } else {
                                // No MTL file, load OBJ directly
                                objLoader.load(MODEL_PATH, onModelLoaded, undefined, onError);
                            }
                        })
                        .catch(() => {
                            // Error checking MTL, load OBJ directly
                            objLoader.load(MODEL_PATH, onModelLoaded, undefined, onError);
                        });
                    break;
                    
                case 'fbx':
                    const fbxLoader = new THREE.FBXLoader();
                    fbxLoader.load(MODEL_PATH, onModelLoaded, undefined, onError);
                    break;
                    
                case '3ds':
                    const tdsLoader = new THREE.TDSLoader();
                    tdsLoader.load(MODEL_PATH, onModelLoaded, undefined, onError);
                    break;
                    
                default:
                    console.warn(`Unsupported 3D file format: ${extension}. Using fallback model.`);
                    createFallbackModel();
            }
        } else {
            createFallbackModel();
        }
    }

    function createFallbackModel() {
        const geometry = new THREE.BoxGeometry(2, 2, 1);
        const material = new THREE.MeshStandardMaterial({
            color: '#3498db',
            metalness: 0.3,
            roughness: 0.4
        });
        productMesh = new THREE.Mesh(geometry, material);
        productMesh.castShadow = true;
        productMesh.receiveShadow = true;
        productMesh.scale.set(DEFAULT_SCALE, DEFAULT_SCALE, DEFAULT_SCALE);
        scene.add(productMesh);
    }

    function loadAnnotationsFromServer() {
        if (SERVER_ANNOTATIONS && SERVER_ANNOTATIONS.length > 0) {
            SERVER_ANNOTATIONS.forEach(a => {
                addAnnotationAtPosition(a.x, a.y, a.z, a.title, a.content, a.color);
            });
        } else {
            addAnnotationAtPosition(0, 1, 0.6, 'M√†n h√¨nh', 'M√†n h√¨nh ch·∫•t l∆∞·ª£ng cao v·ªõi ƒë·ªô ph√¢n gi·∫£i s·∫Øc n√©t');
            addAnnotationAtPosition(0, -0.5, 0.6, 'B√†n ph√≠m', 'B√†n ph√≠m c∆° h·ªçc v·ªõi ƒë√®n n·ªÅn RGB');
            addAnnotationAtPosition(-1, 0, 0.6, 'C·ªïng k·∫øt n·ªëi', 'Nhi·ªÅu c·ªïng USB-C v√† USB-A');
        }
    }

    function addAnnotationAtPosition(x, y, z, title, content, markerColor = '#3399FF') {
        const annotation = {
            position: new THREE.Vector3(x, y, z),
            title: title,
            content: content,
            color: markerColor,
            element: null
        };

        // Create HTML element for the marker
        const el = document.createElement('div');
        el.className = 'annotation-marker pulsing';
        el.style.borderColor = markerColor;
        el.dataset.title = title;
        
        el.onclick = (e) => {
            e.stopPropagation();
            showAnnotationPopup(annotation);
        };

        document.getElementById('canvas-container').appendChild(el);
        annotation.element = el;
        annotations.push(annotation);
    }

    function forEachMeshMaterial(callback) {
        if (!productMesh) return;

        const invoke = (target) => {
            if (target.isMesh && target.material) {
                callback(target.material, target);
            }
        };

        if (productMesh.traverse) {
            productMesh.traverse(child => invoke(child));
        } else {
            invoke(productMesh);
        }
    }

    function updateAnnotations() {
        const container = document.getElementById('canvas-container');
        const widthHalf = container.clientWidth / 2;
        const heightHalf = container.clientHeight / 2;

        annotations.forEach(a => {
            const vector = a.position.clone();
            
            // If part of a product mesh, we might need to apply the mesh's transform
            if (productMesh) {
                vector.applyMatrix4(productMesh.matrixWorld);
            }

            vector.project(camera);

            // Check if marker is behind the camera
            if (vector.z > 1) {
                a.element.style.display = 'none';
                return;
            }

            const xPos = (vector.x * widthHalf) + widthHalf;
            const yPos = -(vector.y * heightHalf) + heightHalf;

            a.element.style.display = 'flex';
            a.element.style.left = `${xPos}px`;
            a.element.style.top = `${yPos}px`;
        });
    }

    function showAnnotationPopup(annotation) {
        const popup = document.getElementById('annotation-popup');
        const container = document.getElementById('canvas-container');
        document.getElementById('annotation-title').textContent = annotation.title;
        document.getElementById('annotation-content').textContent = annotation.content;
        
        popup.style.display = 'block';
        
        const rect = annotation.element.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        const popupRect = popup.getBoundingClientRect();

        let left = (rect.left + rect.width / 2) - containerRect.left;
        let top = rect.top - containerRect.left - 10; // 10px offset

        // Prevent overflow
        if (left + popupRect.width / 2 > containerRect.width) {
            left = containerRect.width - popupRect.width / 2 - 20;
        }
        if (left - popupRect.width / 2 < 0) {
            left = popupRect.width / 2 + 20;
        }

        popup.style.left = `${left}px`;
        popup.style.top = `${rect.top - containerRect.top}px`;
    }

    function closeAnnotation() {
        document.getElementById('annotation-popup').style.display = 'none';
    }

    function addAnnotation() {
        const title = prompt('Nh·∫≠p ti√™u ƒë·ªÅ ch√∫ th√≠ch:');
        if (!title) return;
        
        const content = prompt('Nh·∫≠p n·ªôi dung ch√∫ th√≠ch:');
        if (!content) return;

        // Add annotation at center of product
        addAnnotationAtPosition(0, 1, 0.6, title, content);
    }

    function resetCamera() {
        camera.position.set(CAMERA_POSITION.x, CAMERA_POSITION.y, CAMERA_POSITION.z);
        controls.reset();
    }

    function toggleWireframe() {
        wireframeMode = !wireframeMode;
        forEachMeshMaterial(material => {
            material.wireframe = wireframeMode;
        });
    }


    function enterAR() {
        // Removed as requested
    }

    function enterVR() {
        // Removed as requested
    }

    function addToCart3D() {
        // Add product to cart via AJAX
        $.ajax({
            type: "POST",
            url: "@Url.Action("Add", "Cart")",
            data: { Id: @Model.Id },
            success: function (result) {
                Swal.fire("Th√™m gi·ªè h√†ng th√†nh c√¥ng t·ª´ 3D Viewer!");
            },
            error: function (xhr, status, error) {
                Swal.fire("C√≥ l·ªói x·∫£y ra khi th√™m v√†o gi·ªè h√†ng.");
            }
        });
    }

    function onWindowResize() {
        const container = document.getElementById('canvas-container');
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        updateAnnotations();
        renderer.render(scene, camera);
    }

    // Raycasting for annotation clicks
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onMouseClick(event) {
        const container = document.getElementById('canvas-container');
        const rect = container.getBoundingClientRect();
        
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);

        for (let i = 0; i < intersects.length; i++) {
            const object = intersects[i].object;
            if (object.userData.annotation) {
                const annotation = object.userData.annotation;
                showAnnotationPopup(annotation, 
                    annotation.position.x, 
                    annotation.position.y, 
                    annotation.position.z);
                break;
            }
        }
    }

    // Initialize when page loads
    window.addEventListener('load', function() {
        init3D();
        document.getElementById('threejs-canvas').addEventListener('click', onMouseClick);
    });
</script>

@section Scripts {
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
}

